### 存储引擎的选用

 **MyISAM**：默认的 MySQL 插件式存储引擎。如果应用是**以读操作和插入操作为主， 只有很少的更新和删除操作**，并且对**事务的完整性、并发性要求不是很高**MyISAM 是在 Web、数据仓储和其他应用环境下最常使用的存储引擎之一。



 **InnoDB**：用于**事务处理应用程序**，支持外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询以外，还包括很多的更新、 删除操作，那么 InnoDB 存储引擎应该是比较合适的选择。InnoDB 存储引擎除了有效地降低 由于删除和更新导致的锁定，还可以确保事务的完整提交（Commit）和回滚（Rollback）,对于类似计费系统或者财务系统等对数据准确性要求比较高的系统，InnoDB 都是合适的选择。 



 **MEMORY**：将所有数据保存在 RAM 中，在需要快速定位记录和其他类似数据的环境下，可提供极快的访问。MEMORY 的缺陷是对表的大小有限制，太大的表无法 CACHE 在内存中，其次是要确保表的数据可以恢复，数据库异常终止后表中的数据是可以恢复的。**MEMORY 表通常用于更新不太频繁的小表，用以快速得到访问结果**。 


 **MERGE**：用于将一系列等同的 MyISAM 表以逻辑方式组合在一起，并作为一个对象 引用它们。MERGE 表的优点在于可以突破对单个 MyISAM 表大小的限制，并且通过将不同 的表分布在多个磁盘上，可以有效地改善 MERGE 表的访问效率。这对于诸如**数据仓储**等 VLDB 环境十分适合。



**一、MyISAM引擎** 
MyIASM是MySQL默认的引擎，但是它没有提供对数据库事务的支持，也不支持行级锁和外键，因此当INSERT(插入)或UPDATE(更新)数据时即写操作需要锁定整个表，效率便会低一些。不过和Innodb不同，MyIASM中存储了表的行数，于是SELECT COUNT(*) FROM TABLE时只需要直接读取已经保存好的值而不需要进行全表扫描。如果表的读操作远远多于写操作且不需要数据库事务的支持，那么MyIASM也是很好的选择。 
**二、Innodb引擎** 
Innodb引擎提供了对数据库ACID事务的支持，并且实现了SQL标准的四种隔离级别，MySQL运行时Innodb会在内存中建立缓冲池，用于缓冲数据和索引。但是该引擎不支持FULLTEXT类型的索引，而且它没有保存表的行数，当SELECT COUNT(*) FROM TABLE时需要扫描全表。当需要使用数据库事务时，该引擎当然是首选。由于锁的粒度更小，写操作不会锁定全表，所以在并发较高时，使用Innodb引擎会提升效率。但是使用行级锁也不是绝对的，如果在执行一个SQL语句时MySQL不能确定要扫描的范围，InnoDB表同样会锁全表。 
**三、使用场景** 
大尺寸的数据集趋向于选择InnoDB引擎，因为它支持事务处理和故障恢复。数据库的大小决定了故障恢复的时间长短，InnoDB可以利用事务日志进行数据恢复，这会比较快。主键查询在InnoDB引擎下也会相当快，不过需要注意的是如果主键太长也会导致性能问题。大批的INSERT语句(在每个INSERT语句中写入多行，批量插入)在MyISAM下会快一些，但是UPDATE语句在InnoDB下则会更快一些，尤其是在并发量大的时候。 
引用：http://blog.csdn.net/lulei1217/article/details/50954232