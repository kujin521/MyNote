# 并发任务

![image-20201113144544365](https://raw.githubusercontent.com/kujin521/Typora_images/master/img/currthrad.png)



## 案例

```java
package chapter.ch10.sec01;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

/**
 * Runnable 线程接口<br>
 *     可以异步执行 但不会返回结果<br>
 *     ExecutorService将任务实例列入执行计划<br>
 *     run方法在线程中执行<br>
 *     通过使用单独处理器或同一处理器的不同时间片 多个线程可以并发执行
 *
 */
public class RunnableDemo {
    public static void main(String[] args) {
        // 定义一个打印hello的线程
        Runnable hellos = () -> {
            for (int i = 1; i <= 1000; i++) 
                System.out.println("Hello " + i);
        };
        //定义一个goodbyes 线程 打印 Goodbye 1000次
        Runnable goodbyes = () -> {
            for (int i = 1; i <= 1000; i++) 
                System.out.println("Goodbye " + i);
        };
        //Excutors 类有一个工厂方法提供不同调度策略的executor使用
        // 会产生一个针对很多短暂任务或任务大多数事件处于等待状态的程序优化executor
        ExecutorService executor = Executors.newCachedThreadPool();
        //启动一个有序关闭在以前已提交任务的执行中，但没有新的任务将被接受
        executor.execute(hellos);        
        executor.execute(goodbyes);
        //启动一个有序关闭在以前已提交任务的执行中，但没有新的任务将被接受
        executor.shutdown();
    }
}
```

## 原理解析

- **Executor** 	它提供方法来管理终端和方法，可以产生Future为跟踪一个或多个异步任务执行。

  **ExecutorService**可以关闭，这将导致其拒绝新任务。

   提供了关停的两种不同的方法**ExecutorService** 。 

  ​	该**shutdown**方法将使以前提交的任务，以终止之前执行，

  ​	而**shutdownNow**方法阻止启动并试图停止当前正在执行的任务等待任务。 

  一旦终止，执行者没有任务积极执行，也没有任务等待执行，并没有新的任务可提交。 

  未使用**ExecutorService**应关闭，以允许其资源的回收。

  

  

  方法submit延伸碱方法**Executor.execute(Runnable)**通过创建并返回一个Future可用于取消执行和/或等待完成。

   方法invokeAny和invokeAll执行最常用形式批量执行，执行任务集合，然后等待至少一个，或全部完成。 （类ExecutorCompletionService可用于这些方法中的写入定制的变体。）
  


## Executor