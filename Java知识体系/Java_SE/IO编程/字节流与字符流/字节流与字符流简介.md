**字节流:OutputStream InputStream**

**字符流: Writer Reader**

执行资源操作的步骤:

1. 如果操作的是文件,那么首先要通过File类对象找到一个要操作文件的路径 (路径可能存在,也可能不存在,如果不存在 则要创建路径)
2. 通过字节流或字符流 的子类 为字节流或字符流的对象实例化(向上转型)
3. 执行 读写 操作
4. 一定要关闭操作资源 (close()) 资源一定要关闭

# OutputStream

### 类结构

![image-20200921194546027](../../../../../AppData/Roaming/Typora/typora-user-images/image-20200921194546027.png)

> **java 在1.7 版本加入了AutoCloseable 接口 在try 里的对象 可自动关闭**

测试代码

```java
File file = new File("/aa");
try (OutputStream out=new FileOutputStream(file,true)){
    out.write("字符数组".getBytes());
} catch (FileNotFoundException e) {
    e.printStackTrace();
} catch (IOException e) {
    e.printStackTrace();
}
```

# 管道流

> 可以在两个线程之间通信, 分为 管道输出流(PipedOutputStream,PipedWriter) 管道输入流 (PipedInputStream PipedReader)

![image-20200921203744259](https://raw.githubusercontent.com/kujin521/Typora_images/master/img/image-20200921203744259.png)

实例代码

```java
package PipIStream;

import org.junit.jupiter.api.Test;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;

/**
 * 类：管道流 实现连个线程 管道IO通信
 * 编写人：kujin
 * 创建时间：2020/9/21
 * 修改时间：2020/9/21
 */
class SendThread implements Runnable{   //数据发送线程
    private PipedOutputStream outputStream; //管道输出流

    public SendThread() {   //实例化管道输出流
        this.outputStream = new PipedOutputStream();
    }

    public PipedOutputStream getOutputStream() { //获取管道输出流
        return outputStream;
    }
    @Override
    public void run() {
        try {
            this.outputStream.write("管道流通信 线程之间IO操作".getBytes());   //数据发送
            this.outputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
class ReceiveThread implements Runnable{    //数据接收
    private PipedInputStream inputStream;   //管道输入流

    public PipedInputStream getInputStream() {  //获取管道输入流
        return inputStream;
    }

    public ReceiveThread() {    //创建管道输入流
        this.inputStream = new PipedInputStream();
    }

    @Override
    public void run() { //数据读取
        byte[] bytes=new byte[1024];    //读取缓冲区
        int len=0;  //定义读取长度
        ByteArrayOutputStream bos = new ByteArrayOutputStream();    //通过内存流保存内容
        try {
            while ((len=this.inputStream.read(bytes))!=-1){ //循环遍历 读取内容
                bos.write(bytes,0,len);
            }
            System.out.println(new String(bos.toByteArray()));  //输出数据
            bos.close();    //关闭内存流
        } catch (IOException e) {
            e.printStackTrace();
        }
        try {
            this.inputStream.close();   //关闭输入流
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
public class Demo {
    @Test
    public void testPipInputStream() throws IOException {
           SendThread sned=new SendThread();    //创建发送线程
           ReceiveThread receiveThread=new ReceiveThread(); //创建接收线程
           sned.getOutputStream().connect(receiveThread.getInputStream());  //****管道连接
           new Thread(sned,"消息发送线程").start();
           new Thread(receiveThread,"消息接收").start();
    }
}
```

# 缓冲输入流

