# 二叉树

时间复杂度为O(logn)

在二叉树结构中, 所有数据都保存在节点 Node 中 , 每一个节点又会分为左右两个子节点

在储存时 比根节点 数据小的 保存在 左子节点

比 根节点 数据大 的 保存至右子节点

没有子节点的节点 称为 叶子节点

```java
package base;

import org.w3c.dom.Node;

import java.util.Arrays;

/**
 * 类：二叉树
 * 编写人：kujin
 * 创建时间：2020/9/21
 * 修改时间：2020/9/21
 */
class BinaryTree<T extends Comparable<T>>{  //二叉树结构
    private class Node {
        private Comparable<Comparable<T>> data; //保存数据为Comparable
        private Node parent;    //父节点
        private Node left;  //左子节点
        private Node right; //右子节点

        public Node(Comparable<Comparable<T>> data) {   //保存数据
            this.data = data;
        }

        /**
         * 实现节点数据的适当位置的存储
         *
         * @param newNode
         */
        public void addNode(Node newNode) {
            if (newNode.data.compareTo((T) this.data) <= 0) {   //比当前节点数据小
                if (this.left == null) {   //没有左子节点
                    this.left = newNode;  //保存左子节点
                    newNode.parent = this; //保存父节点
                } else { //存在左子节点
                    this.left.addNode(newNode); //递归判断
                }
            } else { //比当前节点数据大
                if (this.right == null) {   //没有左子节点
                    this.right = newNode;  //保存右子节点
                    newNode.parent = this; //保存父节点
                } else { //存在右子节点
                    this.left.addNode(newNode); //递归判断
                }
            }
        }
        /**
         * 实现所有数据的获取处理 按照中序遍历完成
         */
        public void toArrayNode() {
            if (this.left != null) {   //左子节点存在
                this.left.toArrayNode();    //递归调用
            }
            BinaryTree.this.returnData[BinaryTree.this.foot++] = this.data;
            if (this.right != null) {
                this.right.toArrayNode();
            }
        }
    }
    //------------------------二叉树功能实现------------------------
    private Node root;
    private int count;
    private Object[] returnData;
    private int foot;

    public void add(Comparable data){
        if (data==null){
            throw new NullPointerException("保存的数据不能为空");
        }
        //所有数据本身不具备有节点关系的匹配, 将其包装在Node类中
        Node newNode=new Node(data);
        if (this.root==null){
            this.root=newNode;
        }else {
            this.root.addNode(newNode);
        }
        this.count++;
    }
    public Object[] toArray(){
        if (this.count==0){
            return null;
        }
        this.returnData=new Object[this.count];
        this.foot=0;
        this.root.toArrayNode();
        return this.returnData;
    }
}
class Member implements Comparable<Member>{
    private String name;
    private int age;

    public Member(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public Member() {
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public int compareTo(Member o) {
        return this.age-o.age;
    }

    @Override
    public String toString() {
        return "Member{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
public class BinaryTreeDemo {
    public static void main(String[] args) {
        BinaryTree<Member> tree=new BinaryTree<>();
        tree.add(new Member("张三",17));
        tree.add(new Member("李思思",18));
        tree.add(new Member("汪芜",16));
        System.out.println(Arrays.toString(tree.toArray()));
    }
}
```