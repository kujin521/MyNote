## .NET简介

> .NET 是用于应用程序开发的生态系统

你可能想知道框架所支持的应用模型。 使用下表将应用模型映射到 .NET 框架。

| 应用模型   | 框架                                  | 说明                                                         |
| :--------- | :------------------------------------ | :----------------------------------------------------------- |
| Web        | ASP.NET Core                          | 用于生成服务器端逻辑的框架。                                 |
| Web        | ASP.NET Core MVC                      | 用于为网页或 Web API 生成服务器端逻辑的框架。                |
| Web        | ASP.NET Core Razor Pages              | 用于生成服务器生成的 HTML 的框架。                           |
| Web 客户端 | Blazor                                | Blazor 是 ASP.NET Core 的一部分。 它的两种模式允许通过套接字进行文档对象模型 (DOM) 操作，作为运行服务器端代码的通信工具，或者作为在浏览器上运行已编译 C# 的 WebAssembly 实现。 |
| 桌面       | WinForms                              | 用于生成“战舰灰色”Windows 风格应用程序的框架。               |
| 桌面       | Windows Presentation Foundation (WPF) | 一个框架，用于生成符合不同外形规格的动态桌面应用程序。 WPF 允许外形元素在丰富的动画库的帮助下执行移动、淡出、滑动和其他效果。 |
| 移动       | Xamarin                               | 允许 .NET 开发人员为 iOS 和 Android 设备生成应用。           |

此外，.NET 还支持常用的第三方及开源游戏开发环境和 Unity 等引擎。

## 设置环境

> 以选择 Visual Studio 2019 或 Visual Studio Code 和 .NET 软件开发工具包 (SDK)。

## 在.NET项目中添加包

> .NET 附带许多核心库，可处理从文件管理到 HTTP 再到压缩文件各种任务。 此外还有一个巨大的第三方库生态系统。 可以使用 NuGet（.NET 包管理器）安装这些库并在应用程序中使用它们。
>
> 可将第三方库视为包，并将其存储在存储库中。 包由一个或多个库组成，可将这些库添加到应用程序中，以便利用其功能。

典型的安装命令如下所示：

```bash
dotnet add package <name of package>
```

### NuGet 注册表和 dotnet 工具

> 运行 `dotnet add package <name of dependency>` 时，.NET 会转到称为 NuGet.org 注册表的全局注册表，并查找要下载的代码。 它位于 `https://nuget.org`。 如果使用浏览器访问此页面，也可以在此页面中浏览包。 每个包都有可以访问的专用网站。

```asp
--显示所有包
dotnet list package
```

## 创建示例 .NET 项目

1. 在 Visual Studio Code 中，选择“文件” > “打开文件夹”。

2. 在选择的位置中创建名为 DotNetDependencies 的新文件夹，然后单击“选择文件夹”。

3. 从主菜单中选择“视图” > “终端”，以便从 Visual Studio Code 中打开集成终端。

4. 在终端窗口中，复制粘贴以下命令。

   ```.net
   dotnet new console
   ```

   ```bash
   -| bin
   -| obj
   -| DotNetDependencies.csproj
   -| Program.cs
   ```

5. 运行hello world

   ```asp
   dotnet run
   ```

1. 添加第三方框架

```.net
dotnet add package Humanizer --version 2.7.9
```

2. 打开 DotNetDependencies.csproj 文件并找到 `ItemGroup` 部分。 现在应会出现如下所示的条目：

```xml
<ItemGroup>
    <PackageReference Include="Humanizer" Version="2.7.9 />
</ItemGroup>
```

3. 在 Program.cs 文件顶部添加以下内容来初始化 Humanizer：

4. 代码

   ```c#
   using System;
   using Humanizer;
   
   namespace ConsoleApp
   {
       class Program
       {
           static void Main(string[] args)
           {
               Console.WriteLine("Quantities:");
               HumanizeQuantities();
   
               Console.WriteLine("\nDate/Time Manipulation:");
               HumanizeDates();
           }
   
           static void HumanizeQuantities()
           {
               Console.WriteLine("case".ToQuantity(0));
               Console.WriteLine("case".ToQuantity(1));
               Console.WriteLine("case".ToQuantity(5));
           }
   
           static void HumanizeDates()
           {
               Console.WriteLine(DateTime.UtcNow.AddHours(-24).Humanize());
               Console.WriteLine(DateTime.UtcNow.AddHours(-2).Humanize());
               Console.WriteLine(TimeSpan.FromDays(1).Humanize());
               Console.WriteLine(TimeSpan.FromDays(16).Humanize());
           }
       }
   }
   
   ```

   

5. 运行结果

   ```输出
   Quantities:
   0 cases
   1 case
   5 cases
   
   Date/Time Manipulation:
   yesterday
   2 hours ago
   1 day
   2 weeks
   ```

### 依赖项更新

- **主版本**。 最左边的数字。 例如 1.0.0 中的 1。 此数字发生更改意味着代码可能出现中断性变更。 可能需要重写部分代码。
- **次要版本**。 中间的数字。 例如 1.2.0 中的 2。 此数字发生更改意味着添加了新功能。 你的代码仍可正常工作。 接受更新通常是安全的。
- **修补程序版本**。 最右边的数字。 例如 1.2.3 中的 3。 此数字发生更改意味着应用了一个更改，修复了代码中应正常工作的内容。 接受更新应是安全的。

下表说明了每个版本类型的版本号如何更改：

| 类型         | 发生的更改         |
| :----------- | :----------------- |
| 主版本       | 1.0.0 更改为 2.0.0 |
| 次要版本     | 1.1.1 更改为 1.2.0 |
| 修补程序版本 | 1.0.1 更改为 1.0.2 |

### 配置项目文件以进行更新

添加一个或多个依赖项时，请考虑配置项目文件，以便在还原、生成或运行项目时获得可预测的行为。 你可传达要对包采取的方法。 NuGet 包含版本范围概念和可变版本概念。

首先讨论版本范围。 这是一种特殊的表示法，用于指定你希望解析的特定版本范围。

| 表示法    | 应用的规则    | 说明                                     |
| :-------- | :------------ | :--------------------------------------- |
| 1.0       | x >= 1.0      | 最低版本（包含）                         |
| (1.0,)    | x > 1.0       | 最低版本（独占）                         |
| [1.0]     | x == 1.0      | 精确的版本匹配                           |
| (,1.0]    | x ≤ 1.0       | 最高版本（包含）                         |
| (,1.0)    | x < 1.0       | 最高版本（独占）                         |
| [1.0,2.0] | 1.0 ≤ x ≤ 2.0 | 精确范围（包含）                         |
| (1.0,2.0) | 1.0 < x < 2.0 | 精确范围（独占）                         |
| [1.0,2.0) | 1.0 ≤ x < 2.0 | 混合了最低版本（包含）和最高版本（独占） |
| (1.0)     | 无效          | 无效                                     |

`dotnet list package --outdated` 命令列出了已过时的包

建议的工作流是按以下顺序运行这些命令：

1. 运行 `dotnet list package`。 此命令可列出所有已过时的包。 它通过 `Requested`、`Resolved` 和 `Latest` 列提供信息。
2. 运行 `dotnet add package <package name>`。 如果运行此命令，它将尝试更新到最新版本。 你可选择传入 `--version=<version number/range>`。

可通过追加 `--prerelease` 参数来安装最新的预发布包。

```shell
dotnet add package Humanizer --prerelease
```

## VS Code调试

在开发人员生涯中，总有一刻你会问自己：

> 为什么我的代码不工作？

提出此问题是任何开发人员日常工作的常规环节。 诀窍在于用最少的时间熟练查找并修复 bug，使挫折感降到最低。 当程序中出现 bug 时，每个人通常都有自己的处理方法。 你可能已经尝试过这些调试方法的一种或几种：

- 再次尝试运行程序，因为程序应该会正常工作。
- 边泡澡边思考。
- 再次阅读代码以找出问题。
- 到外面散散步。
- 在代码中编写几个 `Console.WriteLine("here")` 消息。

### 断点

### Visual Studio Code 调试器概述

设置断点并启动应用后，屏幕上将显示新的信息面板和控件。

![Visual Studio Code 调试器概述的屏幕截图。](https://raw.githubusercontent.com/kujin521/Typora_images/master/img/20210102122036.png)

1. 调试器启动控件
2. 变量状态
3. 受监视的变量状态
4. 当前调用堆栈
5. 调用堆栈
6. 执行控件
7. 当前执行步骤
8. 调试控制台

### 控件执行

可以使用这些控件来控制程序的执行流。

![Visual Studio Code 调试器执行控件的屏幕截图。](https://raw.githubusercontent.com/kujin521/Typora_images/master/img/20210102122229.png)

从左到右，控件为：

- 继续或暂停执行。 如果执行已暂停，则它将继续，直到命中下一个断点。 如果程序正在运行，则按钮会切换到暂停按钮，可以使用该按钮来暂停执行。
- 单步跳过。 执行当前上下文中的下一个代码语句。
- 单步执行。 与单步跳过类似，但如果下一个语句是函数调用，则转到该函数的第一个代码语句（与 `step` 命令相同）。
- 单步跳出。如果在函数内部，则执行该函数的其余代码，并在初始函数调用后跳回到该语句（与 `out` 命令相同）。
- 重启。 从头开始重启程序。
- 停止。 结束执行并退出调试器。

### .NET 应用程序中的日志记录和跟踪

- System.Console
  - 始终启用，并始终写入控制台。
  - 适用于客户可能需要在发行版中看到的信息。
  - 由于这是最简单的方法，所以常常用于临时调试。 此调试代码通常不会签入到源代码管理中。
- System.Diagnostics.Trace
  - 仅在定义 `TRACE` 时启用。
  - 写入附加侦听器，默认情况下为 DefaultTraceListener。
  - 创建将在大多数生成中启用的日志时，请使用此 API。
- System.Diagnostics.Debug
  - 仅在定义 `DEBUG` 时才启用（处于调试模式时）。
  - 写入附加调试器。
  - 创建仅在调试生成中启用的日志时，请使用此 API。

```c#
Console.WriteLine("This message is readable by the end user.")
Trace.WriteLine("This is a trace message when tracing the app.");
Debug.WriteLine("This is a debug message just for developers.");
```

## 文件操作

> C# 使用 `System.IO` 中的类型来读取文件系统，以查找文件和目录。

### 栗子

例如，Tailwind Traders 有一个名为“stores”（门店）的根文件夹。 在该文件夹中，子文件夹是按门店编号组织的。 这些文件夹中包含销售总额文件和清单文件。 结构如下所示：

📂 stores
    📄 sales.json
    📄 totals.txt
    📂 201
       📄 sales.json
       📄 salestotals.json
       📄 inventory.txt
    📂 202

```c#
using System;
using System.IO;
using System.Collections.Generic;

namespace files_module
{
    class Program
    {
        static void Main(string[] args)
        {
            var files = FindFiles("stores");

            foreach (var file in files)
            {
                Console.WriteLine(file);
            }
        }

        static IEnumerable<string> FindFiles(string folderName)
        {
            List<string> salesFiles = new List<string>();
    
            var foundFiles = Directory.EnumerateFiles(folderName, "*", SearchOption.AllDirectories);
    
            foreach (var file in foundFiles)
            {
                if (file.EndsWith("sales.json"))
                {
                    salesFiles.Add(file);
                }
            }
    
            return salesFiles;
        }
    }
}
```

### 文件路径操作

//确定当前目录
            Console.WriteLine(Directory.GetCurrentDirectory());
            //使用特殊目录
            string docPath = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
            Console.WriteLine(docPath);
            //特殊路径字符
            Console.WriteLine($"stores{Path.DirectorySeparatorChar}201");

```c#
        // returns:
        // stores\201 on Windows
        //
        // stores/201 on macOS

        //联接路径
        Console.WriteLine(Path.Combine("stores", "201")); // outputs: stores/201

        //确定文件扩展名
        Console.WriteLine(Path.GetExtension("sales.json")); // outputs: .json

        //获取需要了解的有关文件或路径的所有信息
        string fileName = $"stores{Path.DirectorySeparatorChar}201{Path.DirectorySeparatorChar}sales{Path.DirectorySeparatorChar}sales.json";

        FileInfo info = new FileInfo(fileName);

        Console.WriteLine($"Full Name: {info.FullName}{Environment.NewLine}" +
            $"Directory: {info.Directory}{Environment.NewLine}" +
            $"Extension: {info.Extension}{Environment.NewLine}" +
            $"Create Date: {info.CreationTime}"); // And many more
```
### 创建文件和目录

创建目录

```c#
//下面的方法在“201”文件夹内创建一个名为“newDir”的新文件夹。
Directory.CreateDirectory(Path.Combine(Directory.GetCurrentDirectory(), "stores","201","newDir"));
```

确保目录存在

```c#
bool doesDirectoryExists = Directory.Exists(filePath);
```

创建文件

```c#
//此代码创建一个名为“greeting.txt”的文件，其中包含文本“Hello World!” 。
File.WriteAllText(Path.Combine(Directory.GetCurrentDirectory(), "greeting.txt"), "Hello World!");
```

