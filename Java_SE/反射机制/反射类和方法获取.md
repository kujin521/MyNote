## 反射的常用方式

### **通过反射获取带参数的构造方法**(Constrtor)

```java
/**
 * 获取无参构造函数
 * @param aClass
 * @throws NoSuchMethodException
 * @throws InstantiationException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
private static void getConstructor_demo2(Class<?> aClass) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
    Constructor<?> constructor = aClass.getConstructor();
    Person person= (Person) constructor.newInstance();
    person.setAge(19);
    person.setName("kujin");
    System.out.println(person);
}
```

```java
/**
     * 获取有参构造函数
     * @param aClass
     * @throws NoSuchMethodException
     * @throws InstantiationException
     * @throws IllegalAccessException
     * @throws InvocationTargetException
     */
    private static void getConstructor_demo1(Class<?> aClass) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
        Constructor<?> constructor = aClass.getConstructor(String.class, Integer.class);
        Person person= (Person) constructor.newInstance("String属性参数",10);
        System.out.println(person);
    }
```

### **通过反射获取成员变量并使用**

```java
/**
 * 通过反射获取Field
 * @param aClass
 * @param person
 * @throws NoSuchFieldException
 * @throws IllegalAccessException
 */
private static void getField_Demo1(Class<?> aClass, Person person) throws NoSuchFieldException, IllegalAccessException {
    //Field eat = aClass.getField("name");    //返回一个字段 1.该对象是public 2.在父类接口有 3.如果12不符合 NoSuchFieldException被抛出。
    Field name = aClass.getDeclaredField("name");   //获取声明的字段,即所有在类声明的字段 包括private S级别
    name.setAccessible(true);   //由于获取到的字段 还是private 需要对其获取access(访问)权限
    name.set(person,"张三");   //Field 设置 (要修改的对象, 对象内的值)
    System.out.println(person);
}
```

### **通过反射获取成员方法并使用(私有成员方法参考Field)**

```java
/**
 * 获取有参的内部方法
 * 在学习框架时 利用反射机制 去获取 内部参数 和变量 去进行修改 达到自己想要的效果
 * @param aClass
 * @param person
 * @throws NoSuchMethodException
 * @throws IllegalAccessException
 * @throws InvocationTargetException
 */
private static void getMethod_demo1(Class<?> aClass, Person person) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {
    Method eat = aClass.getMethod("eat", String.class); //获取有参的方法
    //person.setName("kujin");
    eat.invoke(person,"苹果");    //执行方法(对象,方法参数)
}
```

### **通过反射越过泛型检查**

> ArrayList<Integer>的一个对象 在这个集合中添加一个字符串数组 如何实现
> **泛型**只 在**编译器有效** 在**运行时被擦除掉**
> 通过反射 获取ArrayList 对象 得到 add 方法 利用**invoke** 执行方法添加字符串类型

```java
/**
 * ArrayList<Integer>的一个对象 在这个集合中添加一个字符串数组 如何实现
 * 泛型只 在编译器有效 在运行时被擦除掉
 * 通过反射 获取ArrayList 对象 得到 add 方法 利用invoke 执行方法添加字符串类型
 */
private static void demo_arrayList_Reflect() throws Exception {
    ArrayList<Integer> list =new ArrayList<>();
    list.add(111);
    list.add(222);
    //获取字节码对象
    Class<?> clazz = Class.forName("java.util.ArrayList");
    Method m=clazz.getDeclaredMethod("add",Object.class);
    m.invoke(list,"添加字符串");
    System.out.println(list);
}
```

### 利用反射设置属性

```java
/**
 * 利用反射 设置 属性值
 */
private static void demo_tool_Reflect() throws NoSuchFieldException, IllegalAccessException {
    Person person=new Person("李四",12);
    System.out.println(person);
    //利用反射 设置属性值
    setProperty(person,"name","张三");
    System.out.println(person);
}

private static void setProperty(Object o, String name, Object value) throws NoSuchFieldException, IllegalAccessException {
    Class clazz=o.getClass();
    Field f = clazz.getDeclaredField(name);
    f.setAccessible(true);
    f.set(o,value);
}
```

### 通过配置文件进行反射

config.properties

```properties
com.kujin.reflect.MyThread
```

主函数

```java
/**
 * 通过反射 利用配置文件执行反射方法
 */
private static void demo_proertyfile_reflect() throws Exception {
    BufferedReader br=new BufferedReader(new FileReader("config.properties"));
    Class clazz=Class.forName(br.readLine());

    MyThread myThread = (MyThread) clazz.newInstance(); //通过字节码文件 创建字节码对象
    myThread.run();
}
```

利用反射调用的类

```java
class MyThread{
    public void run(){
        System.out.println("welcome to Reflect");
    }
}
```

### 动态代理简单了解

**InvocationHandler**是代理实例的调用处理程序实现的接口。
每个代理实例都有一个关联的调用处理程序。 当一个方法是在代理实例调用，方法调用进行编码，并分发给invoke的调用处理程序的方法。

```java
package com.kujin.reflect.dynamicProxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

/**
 * DynamicProxy_Demo1
 * 动态代理
 *
 * @author kujin
 * 创建时间：2020/10/2
 * @version 1
 */

/**
 * 定义用户接口
 */
interface IUser {
    void add();
    void delete();
}

/**
 * 定义用户实现类
 */
class IUserImpl implements IUser {

    @Override
    public void add() {
        System.out.println("实现添加功能");
    }

    @Override
    public void delete() {
        System.out.println("实现删除功能");
    }
}

/**
 * InvocationHandler是代理实例的调用处理程序实现的接口。
 * 每个代理实例都有一个关联的调用处理程序。 当一个方法是在代理实例调用，方法调用进行编码，并分发给invoke的调用处理程序的方法。
 */
class MyInvocationHandler implements InvocationHandler{
    private Object target;

    public MyInvocationHandler(Object target) {
        this.target = target;
    }

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        System.out.println("动态代理: 权限效验");
        method.invoke(target,args);      //执行被代理对象target 的method
        System.out.println("动态代理: 日志记录");
        return null;
    }
}
public class DynamicProxy_Demo1 {
    public static void main(String[] args) {
        IUser user=new IUserImpl();
        user.add();
        user.delete();

        MyInvocationHandler myInvocationHandler = new MyInvocationHandler(user);
        // 返回接口  类加载器 所有接口列表 方法调度器
        IUser user1= (IUser) Proxy.newProxyInstance(user.getClass().getClassLoader(),user.getClass().getInterfaces(),myInvocationHandler);
        user1.add();
        user1.delete();
    }
}
```

### 扩展案例

```java
package com.kujin.reflect;

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

/**
 * @author kujin
 * 创建时间：2020/10/1
 * @version 1
 */
public class ReflectDemo{
    /**
     * 学习反射机制
     * @param args 运行需要输入的参数数组
     * @throws ClassNotFoundException 抛出的异常
     * @throws IllegalAccessException
     * @throws InstantiationException
     * @throws NoSuchMethodException
     * @throws InvocationTargetException
     * 参考地址 :https://blog.csdn.net/javazejian/article/details/70768369
     */
    public static void main(String[] args) throws ClassNotFoundException, IllegalAccessException,
            InstantiationException, NoSuchMethodException, InvocationTargetException {
        Class<?> clazz=null;
//        获取class对象的应用
        clazz=Class.forName("com.kujin.reflect.User");

        System.out.println("------第一种方法获取 实例化默认方法 User必须无参构造方法 否则抛异常------");
//        User user= (User) clazz.newInstance();        //方法过时
        User user= (User) clazz.getDeclaredConstructor().newInstance();
        user.setAge(18);
        user.setName("库金");
        System.out.println(user);

        System.out.println("--------获取String 带参数的pulic构造函数------------");
        Constructor<?> cs1=clazz.getConstructor(String.class);
        User user1= (User) cs1.newInstance("kujin");
        user1.setAge(19);
        System.out.println("user1 "+user);

        System.out.println("--------取得指定带int和String参数构造函数,该方法是私有构造private------------");
        //私有的构造方法
        Constructor<?> cs2 = clazz.getDeclaredConstructor(int.class, String.class);
        //由于方法是私有的 需设置为可访问的
        cs2.setAccessible(true);
        //创建user对象
        User user2= (User) cs2.newInstance(25,"库金");
        System.out.println(user2);

        System.out.println("------------------获取所有构造包含private--------------------------");

        //获取所有构造包含private
        Constructor<?> cons[] = clazz.getDeclaredConstructors();
        // 查看每个构造方法需要的参数
        for (int i = 0; i < cons.length; i++) {
            //获取构造函数参数类型
            Class<?> clazzs[] = cons[i].getParameterTypes();
            System.out.println("构造函数["+i+"]:"+cons[i].toString() );
            System.out.print("参数类型["+i+"]:(");
            for (int j = 0; j < clazzs.length; j++) {
                if (j == clazzs.length - 1)
                    System.out.print(clazzs[j].getName());
                else
                    System.out.print(clazzs[j].getName() + ",");
            }
            System.out.println(")");
        }

    }
}
class User{
    private int age;
    private String name;

    public User() {
    }

    public User(String name) {
        this.name = name;
    }

    private User(int age, String name) {
        this.age = age;
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public String toString() {
        return "User{" +
                "age=" + age +
                ", name='" + name + '\'' +
                '}';
    }
}
```

